/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rob(TreeNode* root) {
        // subproblem: we aim to find the total money stolen with i as the root, we can either include i or not, if we include it, then we must use the previous when it was not stolen
        // let dp[i][j] be the amount stolen ending at i, where j represents if the ith house was robbed
        // dp[i][0] = max(dp[i - 1][0], dp[i - 1][1]);
        // dp[i][1] = max(dp[i - 1][0] + val_i)

        // 0 = dont include
        // 1 = include

        map<pair<TreeNode *, int>, int> dp;

        doRecurse(root, dp);

        return max(dp[{root, 0}], dp[{root, 1}]);
    }

    void doRecurse(TreeNode *root, map<pair<TreeNode *, int>, int>& dp) {
        if (root == NULL) {
            dp[{root, 1}] = 0;
            dp[{root, 0}] = 0;
            return;
        }
 
        if (dp.count({root->left, 1}) == 0) doRecurse(root->left, dp);
        if (dp.count({root->right, 1}) == 0) doRecurse(root->right, dp);

        int includeCurrLeft = dp[{root->left, 1}];
        int includeCurrRight = dp[{root->right, 1}];
        int dontIncludeCurrLeft = dp[{root->left, 0}];
        int dontIncludeCurrRight = dp[{root->right, 0}];

        dp[{root, 0}] = max(includeCurrLeft, dontIncludeCurrLeft) + max(includeCurrRight, dontIncludeCurrRight);

        dp[{root, 1}] = dontIncludeCurrLeft + dontIncludeCurrRight + root->val;
    }
};
